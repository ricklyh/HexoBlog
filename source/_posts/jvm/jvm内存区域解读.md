---
title: jvm内存区域解读
date: 2018-06-22 18:12:04
tags: [jvm]
categories: jvm
---

## 前言 

  - Java虚拟机在运行时，会把内存空间分为若干个区域，根据《Java虚拟机规范（Java SE 7 版）》的规定，
    Java虚拟机所管理的内存区域分为如下部分：方法区、堆内存、虚拟机栈、本地方法栈、程序计数器
    
   ![jvmMemoryArea](jvmMemoryArea.png "Optional title")

## 方法区
  - 方法区主要用于存储虚拟机加载的类信息、常量、静态变量、以及编译器编译后的代码等数据。在JDK1.7及其之前，
  方法区是堆的一个"逻辑部分"（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（HotSpot对方法区的实现方法）来表示方法区。
    
  - 从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的静态变量、字符串常量池等移到堆内存中,常量池除字符串常量池还有class常量池等），
    这里只是把字符串常量池移到堆内存中；在jdk1.8中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）。
    根据网上的资料结合自己的理解对jdk1.3~1.6、jdk1.7、jdk1.8中方法区的变迁画了张图如下（如有不合理的地方希望读者指出）：
    
    ![jdk](jdkversion.png "Optional title")
  
  - 去永久代的原因有:
    + 字符串存在永久代中，容易出现性能问题和内存溢出。
    + 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
    + 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
    
## 堆内存
   - 堆内存主要用于存放对象和数组，它是JVM管理的内存中最大的一块区域，堆内存和方法区都被所有线程共享，在虚拟机启动时创建。
     在垃圾收集的层面上来看，由于现在收集器基本上都采用分代收集算法，因此堆还可以分为新生代（YoungGeneration）和老年代（OldGeneration），新生代还可以分为 Eden、From Survivor、To Survivor
     
## 程序计数器
   - 程序计数器是一块非常小的内存空间，可以看做是当前线程执行字节码的行号指示器，每个线程都有一个独立的程序计数器，
     因此程序计数器是线程私有的一块空间，此外，程序计数器是Java虚拟机规定的唯一不会发生内存溢出的区域
     
## 虚拟机栈
   - 虚拟机栈也是每个线程私有的一块内存空间，它描述的是方法的内存模型，直接看下图所示：
   ![jvmStack](jvmStack.png "Optional title")
   - 虚拟机会为每个线程分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧，每个栈帧中存储了局部变量表、操作数栈、动态链接、返回地址等。
     一个栈帧就对应 Java 代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，
     每一个 Java 方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程
     
## 本地方法栈
   - 本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是 Java 方法，本地方法栈执行的是本地方法（Native Method）
     其他基本上一致，在 HotSpot 中直接把本地方法栈和虚拟机栈合二为一，这里暂时不做过多叙述
     
## 元空间
   - 上面说到，jdk1.8 中，已经不存在永久代（方法区），替代它的一块空间叫做 “ 元空间 ”，和永久代类似，
     都是 JVM 规范对方法区的实现，但是元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制，
     但可以通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来指定元空间的大小
     
## 总结
   ![jvm](jvm.png "Optional title")